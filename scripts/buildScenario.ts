import 'dotenv/config';
import chokidar from 'chokidar';
import { isAbsolute, resolve } from 'node:path';
import { GENERATED_SCENARIO_PATH, loadScenario, PUBLIC_DIR } from './modules';
import { writeFile } from 'node:fs/promises';
import { VoiceQueue } from './modules/voiceQueue';
import { parseArgs } from 'node:util';

function formatScenarioPath(path: string) {
  const absolutePath = isAbsolute(path) ? path : resolve(process.cwd(), path);

  if (!absolutePath.endsWith('.mnsc')) {
    throw new Error('Scenario file must be a .mnsc file');
  }

  if (!absolutePath.startsWith(PUBLIC_DIR)) {
    throw new Error(
      `Scenario path must be inside the public directory: ${PUBLIC_DIR}`,
    );
  }

  return absolutePath;
}

async function buildScenario() {
  try {
    const scenario = await loadScenario(scenarioPath);

    // Generate TypeScript file
    const timelineTs = `// This file is auto-generated by scripts/buildScenario.ts
import type { VideoScenario } from "./entities";

export const scenario: VideoScenario = ${JSON.stringify(scenario, null, 2)};
  `;
    await writeFile(GENERATED_SCENARIO_PATH, timelineTs, 'utf-8');

    // Generate Voice (Queue)
    voiceQueue.setTasks(
      scenario.talkVoiceTimeline.map((item) => ({
        item,
        voicepeakConfig: scenario.meta.voice,
      })),
    );
    if (!voiceQueue.isRunning) {
      voiceQueue.kick().catch((err) => {
        console.error('Voice queue error:', err);
      });
    }

    console.log(`Scenario built successfully: ${GENERATED_SCENARIO_PATH}`);
  } catch (error) {
    console.error('Error building scenario:', error);
  }
}

const { values, positionals } = parseArgs({
  allowPositionals: true,
  options: {
    watch: {
      type: 'boolean',
      default: false,
      short: 'w',
    },
  },
});
const watchMode = values.watch;
const scenarioPath = formatScenarioPath(positionals[0] ?? process.env.SCENARIO);

const voiceQueue = new VoiceQueue();

if (watchMode) {
  const watcher = chokidar.watch(scenarioPath, {
    ignoreInitial: true,
    awaitWriteFinish: {
      stabilityThreshold: 200,
      pollInterval: 100,
    },
  });

  watcher.on('all', async (_event, _filePath) => {
    await buildScenario();
  });

  watcher.on('error', (error) => {
    console.error('Watcher error:', error);
  });
}

await buildScenario();
